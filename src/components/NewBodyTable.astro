---
interface Hermanos {
  numComunidad: number;
  tipo: string;
  nombres: string;
  observaciones: string;
  hospedaje: string;
}

interface ComunidadFilters {
  numComunidad: number;
  parroquia: string;
  tipo: string;
  nombres: string;
  hospedaje: string;
}

interface Catequistas {
  nombres: string;
  tipo: string;
  observaciones: string;
  hospedaje: string;
}

interface ResumenComus {
  parroquia: string;
  totalComus: number;
  totalMatrimonios: number;
  totalSolteros: number;
  totalSolteras: number;
  totalPersonas: number;
}

interface Props {
  hermanos?: Hermanos[];
  filtersComus?: ComunidadFilters[];
  catequistas?: Catequistas[];
  resumenComus?: ResumenComus[];
}
const { hermanos, filtersComus, catequistas, resumenComus } =
  Astro.props as Props;

// Generar un ID único para este tbody
const tableId = `tbody-${Math.random().toString(36).substr(2, 9)}`;
---

<tbody id={tableId}>
  {
    hermanos &&
      hermanos?.map((hermano) => (
        <tr class="tr-hermanos">
          <td
            class={`td-${hermano.numComunidad}`}
            data-comunidad={hermano.numComunidad}
          >
            {hermano.numComunidad}
          </td>
          <td class={`td${hermano.tipo}-${hermano.numComunidad}`}>
            {hermano.tipo}
          </td>
          <td>{hermano.nombres}</td>
          <td>{hermano.observaciones}</td>
          <td>{hermano.hospedaje}</td>
        </tr>
      ))
  }
  {
    filtersComus &&
      filtersComus?.map((hermano) => (
        <tr class="tr-filters">
          <td
            class={`td-${hermano.numComunidad}`}
            data-comunidad={hermano.numComunidad}
            data-parroquia={hermano.parroquia}
          >
            {hermano.numComunidad}
          </td>
          <td
            class={`tdparroquia-${hermano.numComunidad}`}
            data-parroquia={hermano.parroquia}
            data-comunidad={hermano.numComunidad}
          >
            {hermano.parroquia}
          </td>
          <td>{hermano.tipo}</td>
          <td>{hermano.nombres}</td>
          <td>{hermano.hospedaje}</td>
        </tr>
      ))
  }
  {
    catequistas &&
      catequistas?.map((catequista) => (
        <tr class="tr-catequistas">
          <td>{catequista.nombres}</td>
          <td>{catequista.tipo}</td>
          <td>{catequista.observaciones}</td>
          <td>{catequista.hospedaje}</td>
        </tr>
      ))
  }
  {
    resumenComus &&
      resumenComus?.map((resum) => (
        <tr class="tr-resumen">
          <td>{resum.parroquia}</td>
          <td>{resum.totalComus}</td>
          <td>{resum.totalMatrimonios}</td>
          <td>{resum.totalSolteros}</td>
          <td>{resum.totalSolteras}</td>
          <td>{resum.totalPersonas}</td>
        </tr>
      ))
  }
</tbody>

<script define:vars={{ tableId }} is:inline>
  // Encontrar el tbody específico por su ID
  const tbody = document.getElementById(tableId);

  if (!tbody) return;

  // Función para fusionar celdas en tabla de hermanos (por parroquia)
  const colapsarHermanos = (tbodyElement) => {
    // Fusionar números de comunidad si tienen la misma clase Y son consecutivos
    const tds = tbodyElement.querySelectorAll(
      'td[class^="td-"]:not([data-parroquia])',
    );

    let lastValue = "";
    let lastTD = null;
    let lastClass = "";
    let lastRow = null;

    tds.forEach((td) => {
      const currentClass = td.className;
      const currentRow = td.parentElement;

      // Verificar si es la fila inmediatamente siguiente
      const isConsecutive =
        lastRow && lastRow.nextElementSibling === currentRow;

      if (
        td.textContent === lastValue &&
        td.textContent !== "" &&
        currentClass === lastClass &&
        isConsecutive
      ) {
        if (lastTD) {
          lastTD.rowSpan = (lastTD.rowSpan || 1) + 1;
          td.style.display = "none";
        }
      } else {
        lastValue = td.textContent || "";
        lastClass = currentClass;
        lastTD = td;
      }
      lastRow = currentRow;
    });

    // Fusionar tipos solo si son del mismo número de comunidad Y consecutivos
    const tdsType = tbodyElement.querySelectorAll(
      'td[class^="tdsoltero-"], td[class^="tdsoltera-"], td[class^="tdmatrimonio-"]',
    );

    let lastTypeValue = "";
    let lastTypeTD = null;
    let lastComunidad = "";
    let lastTypeRow = null;

    tdsType.forEach((td) => {
      const className = td.className;
      const comunidadNum = className.split("-")[1];
      const currentRow = td.parentElement;
      const isConsecutive =
        lastTypeRow && lastTypeRow.nextElementSibling === currentRow;

      if (
        td.textContent === lastTypeValue &&
        comunidadNum === lastComunidad &&
        isConsecutive
      ) {
        if (lastTypeTD) {
          lastTypeTD.rowSpan = (lastTypeTD.rowSpan || 1) + 1;
          td.style.display = "none";
        }
      } else {
        lastTypeValue = td.textContent || "";
        lastComunidad = comunidadNum;
        lastTypeTD = td;
      }
      lastTypeRow = currentRow;
    });
  };

  // Función para fusionar celdas en tabla de filtros (con parroquias)
  const colapsarFilters = (tbodyElement) => {
    // Fusionar números de comunidad solo si son de la misma parroquia
    const tds = tbodyElement.querySelectorAll(
      'td[class^="td-"][data-parroquia]',
    );

    let lastValue = "";
    let lastTD = null;
    let lastParroquia = "";

    tds.forEach((td) => {
      const currentParroquia = td.dataset.parroquia || "";

      if (
        td.textContent === lastValue &&
        td.textContent !== "" &&
        currentParroquia === lastParroquia
      ) {
        if (lastTD) {
          lastTD.rowSpan = (lastTD.rowSpan || 1) + 1;
          td.style.display = "none";
        }
      } else {
        lastValue = td.textContent || "";
        lastParroquia = currentParroquia;
        lastTD = td;
      }
    });

    // Fusionar parroquias solo si son del mismo número de comunidad
    const tdsParroquia = tbodyElement.querySelectorAll(
      'td[class^="tdparroquia-"]',
    );

    let lastParroquiaValue = "";
    let lastParroquiaTD = null;
    let lastComunidadParroquia = "";

    tdsParroquia.forEach((td) => {
      const currentComunidad = td.dataset.comunidad || "";
      const currentParroquia = td.textContent?.trim() || "";

      if (
        currentParroquia === lastParroquiaValue &&
        currentComunidad === lastComunidadParroquia &&
        currentParroquia !== ""
      ) {
        if (lastParroquiaTD) {
          lastParroquiaTD.rowSpan = (lastParroquiaTD.rowSpan || 1) + 1;
          td.style.display = "none";
        }
      } else {
        lastParroquiaValue = currentParroquia;
        lastComunidadParroquia = currentComunidad;
        lastParroquiaTD = td;
      }
    });
  };

  // Ejecutar la función apropiada según qué tabla existe en este tbody específico
  const hasHermanos = tbody.querySelector(
    'td[class^="td-"]:not([data-parroquia])',
  );
  const hasFilters = tbody.querySelector("td[data-parroquia]");

  if (hasHermanos && !hasFilters) {
    colapsarHermanos(tbody);
  } else if (hasFilters) {
    colapsarFilters(tbody);
  }
</script>

<style>
  .tr-hermanos,
  .tr-filters {
    transition: background-color 0.2s;

    & td:first-child {
      width: 1%;
      text-align: center;
    }
    & td:nth-child(2) {
      width: 16%;
    }
    & td:nth-child(3) {
      width: 30%;
    }
    & td:nth-child(4) {
      width: 30%;
    }
    & td:nth-child(5) {
      width: 30%;
    }
  }
  & tr:nth-child(even) {
    background-color: #f9f9f9;
  }

  & tr:hover {
    background-color: #f0f0f0;
  }
  & td {
    padding: 4px 6px;
    border: 1px solid var(--color-border);
    /* vertical-align: top; */
  }

  .tr-catequistas td:first-child {
    text-align: left;
  }
</style>
